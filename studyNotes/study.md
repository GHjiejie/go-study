## **1. go数据类型:**

### 1.1 基本数据类型

- **布尔类型:**

- - `bool`: 表示真假，取值为 `true` 或 `false`。

- **数字类型:**

- - **整型:**

- - - `int8`, `int16`, `int32`, `int64`: 有符号整数，分别表示 8、16、32、64 位整数。
    - `uint8`, `uint16`, `uint32`, `uint64`: 无符号整数，分别表示 8、16、32、64 位整数。
    - `int`: 大小取决于操作系统 (32 位或 64 位)。
    - `uint`: 大小取决于操作系统 (32 位或 64 位)。
    - `rune`: 等价于 `int32`，用于表示 Unicode 字符。
    - `byte`: 等价于 `uint8`，用于表示一个字节。

- - **浮点型:**

- - - `float32`: 32 位浮点数。
    - `float64`: 64 位浮点数。

- - **复数类型:**

- - - `complex64`: 由两个 `float32` 值构成的复数。
    - `complex128`: 由两个 `float64` 值构成的复数。

- **字符串类型:**

- - `string`: 用于表示字符串，是不可变的字节序列。

### **1.2 复合数据类型:**

- **数组:** 固定长度的相同类型元素的序列。
- 例如：`var numbers [5]int` 声明一个长度为 5 的整数数组。

- - **切片:** 动态长度的相同类型元素的序列，可以看作是数组的引用。

- 例如：`var names []string` 声明一个字符串切片。

- - **映射 (map):** 键值对的无序集合。

- 例如：`var ages map[string]int` 声明一个键为字符串、值为整数的映射。

- - **结构体 (struct):** 将不同类型的数据组合在一起形成一个新的数据类型。

- 例如：

~~~plain
type Person struct {
    Name string
    Age  int
}
* **指针:**  存储变量内存地址的类型。
   
* 例如：`var ptr *int`  声明一个指向整数的指针。
      
   
   * **函数:**  可以被调用执行的代码块。
   
* 例如：
  
     ```{go
     //如果接收的参数的数据类型都是相同的，我们只在最后一个参数后面写数据类型
     // 如果函数有返回值，我们需要指定函数的返回值的类型，不然会报错
     func add(x int, y int) int {
    return x + y
      }
      
      //所以说上面的代码其实也可以这样写
      func add(x ,y int) int  {
          return x + y
      }
~~~

- **接口:** 定义了一组方法的集合，可以用来实现多态。
- 例如：

~~~plain
type Shape interface {
    Area() float64
}
* **通道 (channel):**  用于并发编程，在 goroutine 之间传递数据。
      
      * 例如：`var ch chan int`  声明一个整数通道。


**3. 其他类型:**

   * **空接口:** `interface{}` 可以表示任何类型的值。
   * **错误类型:** `error` 用于表示错误信息。

希望以上信息能够帮助你更好地理解 Go 语言的数据类型！



## 2.在 Go 语言中，声明数组的方式主要有以下几种：

### **2.1  指定长度:**

   这是最常见的声明数组的方式，你需要指定数组的长度和元素类型。

   ```go
   var arrayName [arrayLength]elementType //这个是基本
~~~

例如：

```plain
var numbers [5]int       // 声明一个长度为 5 的整数数组
   var fruits [3]string    // 声明一个长度为 3 的字符串数组
```

### **2.2 使用数组字面量:**

你可以在声明数组的同时初始化数组的元素，这时可以省略数组的长度，Go 编译器会根据元素的数量自动推断数组的长度。

   var arrayName = [arrayLength]elementType{element1, element2, ...}

例如：

```plain
var numbers = [5]int{1, 2, 3, 4, 5}      // 声明并初始化一个整数数组
   var fruits = [3]string{"苹果", "香蕉", "橙子"}  // 声明并初始化一个字符串数组
```

也可以省略数组长度：

   var numbers = [...]int{1, 2, 3, 4, 5}     // 数组长度自动推断为 5

### **3. 使用** `**:=**` **操作符:**

可以使用 `:=` 操作符简化数组的声明和初始化，这时可以省略 `var` 关键字和变量类型。

   arrayName := [arrayLength]elementType{element1, element2, ...}

例如：

```plain
numbers := [5]int{1, 2, 3, 4, 5}      // 声明并初始化一个整数数组
   fruits := [...]string{"苹果", "香蕉", "橙子"}  // 声明并初始化一个字符串数组，数组长度自动推断
```

**总结:**

Go 语言提供了多种声明数组的方式，你可以根据需要选择最合适的方式。 

无论使用哪种方式，都需要明确指定数组的元素类型，并且数组的长度是固定的，一旦声明就无法改变。

## 3.解释一下在go语言里面的:=运算符的作用？

首先我们看一下这个变量的生命

var variable variableType 

就是 var 变量名 变量类型

比如说下面这个

```plain
var age int
age=18
```

那么我们可以使用 `：=`来简写

这个 `：=`是变量声明与赋值的简写，同时这个运算符也可以**自动推断变量的类型**（需要注意的是：如果是基本数据类型的化，他会自动推断，如果是复合数据类型的化，我们需要做一些处理），go语言底层做的

```plain
age:=18 // 声明一个名为 age 的变量，并将其初始化为 18，age 的类型被推断为 int
//这段代码的效果与上面的是相同的
package main

import "fmt"

func main (){
    arr:=[5]int{1,2,3,4,5}//这里需要指定数组的数据类型，
    arr2:=[5]{1,2,3,4,5}//这里就会报错了
    fmt.Println(arr)
}
```

## 4.在Go语言中使用 `:=` 操作符来声明和初始化复合数据类型时，有一些需要注意的事项：

### 4.1 **数组类型必须显式指定元素类型**

- 当声明数组时，数组的长度和元素类型必须明确指定，否则会导致编译错误。
- 例如：

```plain
arr := [5]int{1, 2, 3, 4, 5} // 正确：指定了长度为5的int类型数组
arr2 := [5]{1, 2, 3, 4, 5}   // 错误：缺少元素类型
```

### 4.2 **切片、映射、和结构体类型的自动推断**

- 对于切片（slice）、映射（map）、和结构体（struct），编译器可以自动推断类型，因此你不需要显式指定类型。
- 例如：

```plain
slice := []int{1, 2, 3, 4, 5}            // 正确：推断出slice类型为 []int
m := map[string]int{"foo": 1, "bar": 2}  // 正确：推断出map类型为 map[string]int
```

### 4.3 **数组与切片的区别**

- 数组的长度是类型的一部分，因此 `[5]int` 和 `[6]int` 是不同的类型，不能互换。
- 切片则没有这个限制，切片类型仅由元素类型决定。
- 例如：

```plain
arr1 := [3]int{1, 2, 3}   // 数组：[3]int
slice := []int{1, 2, 3}   // 切片：[]int
```

### 4.4 **结构体声明**

- 在结构体初始化时，结构体的类型也需要被明确指出。
- 例如：

```plain
type Person struct {
    Name string
    Age  int
}

p := Person{Name: "Alice", Age: 30} // 正确：推断出p的类型为Person
```

### 4.5 **不能重复声明同名变量**

- 在同一作用域内，`:=` 操作符不能用于重复声明已经存在的变量。否则，会导致编译错误。
- 例如：

```plain
x := 10
x := 20  // 错误：x已经被声明
x = 20   // 正确：这是对x的重新赋值，而不是声明
```

### 4.6 **函数返回值**

- 使用 `:=` 可以很方便地接收多个返回值并自动推断类型。
- 例如：

```plain
func getValues() (int, string) {
    return 42, "hello"
}

a, b := getValues()  // a 是 int, b 是 string
```

### 总结

在使用 `:=` 声明和初始化复合数据类型时，确保数组的元素类型和长度明确，利用好编译器的类型推断机制来简化代码。同时要注意在相同作用域内不要重复声明已经存在的变量。

## 5、你对复合数据类型的切片的理解？

[我们可以参考这个B站的视频解析](https://www.bilibili.com/video/BV1B24y1H7Cp/?spm_id_from=333.337.search-card.all.click&vd_source=8042842218049ca155415280646c631b)

切片（Slice）是 Go 语言中一种重要的复合数据类型，它可以看作是 **动态数组**，提供了一种方便、灵活的方式来操作数组的**一部分**。

### 5.1使用切片表达式创建切片

```plain
//一个空的int类型的切片
var slice = []int //声明一个元素类型为空的切片

var slice=[]int{1,2,3,4} //声明一个元素类型为int,长度为4的的一个切片

//我们也可以基于一个数组去进行切片

arr:=[5]int{1,2,3,4,5}

slice :=arr[0:3] //意思就是我声明了一个切片，同时对这个切片进行初始化，初始化的值是从arr数组的下标为0的数开始，切3个数，[1,2,3],他是一个左闭右开的区间

fmt.Println(slice) //[1,2,3]
```

那么这个是如何实现的呢？？？

切片的底层实际上是一个结构体，这个结构体包含三个字段：

- **指针（Pointer）**：指向切片引用的底层数组的起始位置。
- **长度（Length）**：切片中的元素个数，表示当前切片实际包含的元素数量。
- **容量（Capacity）**：从切片的起始位置到底层数组末尾的元素个数，表示切片所能容纳的最大元素个数。

那么我们有上面的概念后，实际上就可以更好的理解使用make去创建切片

### 5.2 使用make创建切片

首先看一下这个如何去使用这种方法创建

```plain
sliceName := make([]elementType, length, capacity) //length:切片的程长度  capacity 切片的容量

//比如说下面这个 
numbers := make([]int, 5, 10)  // 创建一个长度为 5，容量为 10 的整数（int）切片

//实际开发中，我们大多是使用这种:=这种方式，因为只需要一行代码
//如果我们不使用这个语法的化,那么就需要两段代码来实现
var num []int
num=make([]int,5,10)
```

### 5.3 切片的动态扩容

为什么要区分长度和容量？

**长度（Length）**：切片当前实际包含的元素个数。当你对切片执行 `len(slice)` 时，返回的是切片的长度。

**容量（Capacity）**：切片在不进行内存重新分配的情况下，可以扩展的最大长度。当你对切片执行 `cap(slice)` 时，返回的是切片的容量。

```plain
numbers := make([]int, 5, 10) 
fmt.Println(len(numbers)) // 输出 5
fmt.Println(cap(numbers)) // 输出 10
```

切片的长度是动态可变的，如果你向切片中追加元素（使用 `append` 函数）超过了切片的容量，Go 会自动分配一个更大的底层数组，复制现有的切片元素到新数组中，并返回新的切片。

```plain
numbers := make([]int, 5, 5) 
numbers = append(numbers, 6) // 自动扩容
fmt.Println(len(numbers)) // 输出 6
fmt.Println(cap(numbers)) // 输出 10（新分配的容量可能更大，具体取决于 Go 的实现）
```

### 5.4 注意事项

- **切片是引用类型**：切片的底层数组是共享的，因此多个切片可以引用同一个数组的一部分或全部。当一个切片修改了底层数组中的值时，其他引用相同底层数组的切片也会受到影响。
- **小心越界访问**：由于切片可以动态扩展，因此需要谨慎使用，避免超出容量范围导致意外的内存操作错误。

## 6. 你如何理解Go语言里面的make函数?

`make` 函数是 Go 语言中的一个内置函数，用于**创建切片、映射和通道**。 

它与 `new` 函数的区别在于，`make` 函数不仅会分配内存，还会初始化所创建的数据结构。

`**make**` **函数的语法:**

make(T, args...)

其中：

- `T`: 要创建的数据结构的类型，可以是切片 `[]T`、映射 `map[K]V` 或通道 `chan T`。
- `args...`: 可选参数，用于指定数据结构的长度和容量 (切片) 或缓冲区大小 (通道)。

`**make**` **函数的作用:**

- **切片:**`make([]T, len, cap)` 创建长度为 `len`、容量为 `cap` 的切片。
- **映射:**`make(map[K]V)` 创建一个空的映射。
- **通道:**`make(chan T, buf)` 创建一个缓冲区大小为 `buf` 的通道。

`**make**` **函数与** `**new**` **函数的区别:**

- `make` 函数用于创建切片、映射和通道，而 `new` 函数用于创建任何类型的变量。
- `make` 函数会分配内存并初始化所创建的数据结构，而 `new` 函数只会分配内存，并将内存清零。

**使用示例:**

```plain
numbers := make([]int, 5, 10)   // 创建一个长度为 5，容量为 10 的整数切片
ages := make(map[string]int)    // 创建一个空的字符串到整数的映射
ch := make(chan int, 100)       // 创建一个缓冲区大小为 100 的整数通道
```

**总结:**

`make` 函数是 Go 语言中创建切片、映射和通道的常用方法，它能够预先分配内存并初始化数据结构，提高程序效率。 了解 `make` 函数的用法对于编写 Go 程序至关重要。

## 7.go语言里面的根据接受者的类型进行隐式类型转换？

我们下面的函数

```plain
package main

import "fmt"
//声明一个结构体
type Animal struct{
    Name string
    Age int
    PetName string
}

//为这个结构体添加方法(值类型的传递)
func (a Animal) getPetName() string {
    return a.PetName
}

//设置PetName方法(值类型传递)
func (a Animal) setValuePetName(petname string) {
    a.PetName=petname;
}

//设置PetName方法（引用类型的传递）
func (a *Animal) setPointPetName(petname string) {
    a.PetName=petname;
}

func main(){
    
    dog :=Animal{
        Name:"旺财",
        Age:3,
        PetName:"发财",
    }
    
    fmt.Println(dog.getPetName()) //发财
    
    dog.setValuePetName("小黄")
    
    fmt.Println(dog.PetName) //发财
    
    dog.setPointPetName("小黑")  //因为这个方法接收者是结构体指针，所以在go语言内部实际上是做了一个隐式类型转换，所以这段代码等价于 
    // (&dog).setPointPetName("小黑")
    
    fmt.Println(dog.PetName) //小黑
    
}
```

Go语言的底层确实是根据方法接收者的类型来判断是否需要进行隐式转换。

### 隐式转换的机制

在Go语言中，当你调用一个方法时，Go会自动判断方法接收者的类型，并决定是否需要进行隐式的类型转换。

- **值类型接收者**：如果你有一个指针类型的变量并调用一个值类型接收者的方法，Go会自动解引用该指针来获取值类型，从而调用对应的方法。

```plain
dog := &Animal{Name: "旺财", Age: 3, PetName: "发财"}
dog.getPetName() // 等价于 (*dog).getPetName()
```

- **指针类型接收者**：如果你有一个值类型的变量并调用一个指针类型接收者的方法，Go会自动取该变量的地址来获取指针类型，从而调用对应的方法。

```plain
dog := Animal{Name: "旺财", Age: 3, PetName: "发财"}
dog.setPointPetName("小黑") // 等价于 (&dog).setPointPetName("小黑")
```

### 何时发生隐式转换

- 当方法的接收者类型与调用时的变量类型不一致时，Go会在必要时进行隐式转换。
- 如果方法接收者是值类型，而变量是指针类型，Go会自动对指针进行解引用。
- 如果方法接收者是指针类型，而变量是值类型，Go会自动对值取地址。

### 注意

- 隐式转换使得方法调用更加灵活，不需要显式地进行取地址或解引用操作。
- 这种隐式转换只在方法接收者中发生，而不会在普通函数中自动进行。普通函数的参数类型必须与传入参数的类型严格匹配。

### 总结

Go语言确实根据方法的接收者类型来决定是否进行隐式转换。这种机制简化了方法调用的语法，使得代码更简洁易读，同时也保留了操作指针和引用的灵活性。

## 8、go语言里面的如何实现继承？

**在go语言里面实际上是没有继承的这个概念的，我们可以使用组合来实现继承的效果**

通俗的来讲就是在一个结构体里面使用了另一个结构体（我们通常称这个结构体为一个基类，概念大概理解就行，不必死磕哈）

```plain
package main

import "fmt"

// 声明一个通用的结构体，其他的结构体
type Animal struct {
    Name string
    Age  int
}

// Dog结构体要实现对Animal结构体的继承
type Dog struct {
    Animal //里面使用了另一个结构体，或者说就是结构体嵌套，一般开发过程中最好就嵌套一层？？暂时不知道哈
    PetName string
}

func (d *Dog) getPetName() string {
    return d.PetName
}

func main() {
    // 声明一个数据类型为Dog的结构体
    dog := Dog{
        PetName: "小黑",
    }
    dog.Animal.Age = 18
    dog.Animal.Name = "黑大帅"
    
    //实际上下面的代码和上面两行实现的效果是一样的，但是我们需要注意的是，如果Dog这个结构体里面有字段和Animla结构体重复了（比如就是Age），那么go语言是会做一个叫就近原则的，就是说如果你现在使用dog.Age实际上是访问的是Dog结构体自己的Age字段，不会访问到Animal里面的Age字段
    //dog.Age=18
    //dog.Name="黑大帅"
    
    
    fmt.Println(dog.getPetName())

    fmt.Println(dog)

}
```

## 9、 go里面的nil是什么？有什么作用？

在 Go 语言中，`nil` 是一个特殊的预定义标识符，表示 **零值**。

`**nil**` **的含义:**

- **指针:**`nil` 表示一个空指针，它不指向任何内存地址。
- **接口:**`nil` 表示一个空接口，它没有底层类型和值。
- **映射:**`nil` 表示一个空映射，它不包含任何键值对。
- **切片:**`nil` 表示一个空切片，它没有底层数组。
- **通道:**`nil` 表示一个空通道，它不能发送或接收任何值。
- **函数:**`nil` 表示一个空函数，它不执行任何操作。

`**nil**` **的用途:**

* **初始化变量:**  可以使用 `nil` 来初始化指针、接口、映射、切片、通道和函数类型的变量。
* **判断变量是否为空:**  可以使用 `nil` 来判断变量是否为空。
* **表示错误或缺失值:**  可以使用 `nil` 来表示错误或缺失值。


**示例:**

```plain
var p *int = nil  // 初始化一个空指针
var m map[string]int = nil  // 初始化一个空映射
var s []int = nil  // 初始化一个空切片
var c chan int = nil  // 初始化一个空通道

if p == nil {
    fmt.Println("p is nil")
}

if err != nil {
    fmt.Println("Error:", err)
}
```

**总结:**

`nil` 是 Go 语言中一个重要的概念，它表示零值，可以用于初始化变量、判断变量是否为空，以及表示错误或缺失值。

希望以上解释能够帮助你理解 Go 语言中的 `nil`！